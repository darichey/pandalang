use std::str::FromStr;
use crate::ast::*;

grammar;

pub Expr: Box<Expr> = {
    #[precedence(level="0")]
    Int => Box::new(Expr::Int(Int { n: <> })),
    Str => Box::new(Expr::Str(Str { s: <> })),
    Name => Box::new(Expr::Var(Var { name: <>.to_string() })),
    "(" <ExprReset> ")",

    #[precedence(level="1")]
    #[assoc(side="left")]
    <fun:Expr> <arg:Expr> => Box::new(Expr::App(App { fun, arg })),

    #[precedence(level="2")]
    #[assoc(side="left")]
    <left:Expr> "*" <right:Expr> => Box::new(Expr::BinOp(BinOp { left, right, kind: BinOpKind::Mul })),
    <left:Expr> "/" <right:Expr> => Box::new(Expr::BinOp(BinOp { left, right, kind: BinOpKind::Div })),

    #[precedence(level="3")]
    #[assoc(side="left")]
    <left:Expr> "+" <right:Expr> => Box::new(Expr::BinOp(BinOp { left, right, kind: BinOpKind::Add })),
    <left:Expr> "-" <right:Expr> => Box::new(Expr::BinOp(BinOp { left, right, kind: BinOpKind::Sub })),

    #[precedence(level="4")]
    #[assoc(side="right")]
    "let" <patt:Pattern> "=" <value:Expr> "in" <body:Expr> => Box::new(Expr::Let(Let { patt, value, body })),

    #[precedence(level="5")]
    #[assoc(side="right")]
    "fun" <patt:Pattern> "->" <body:Expr> => Box::new(Expr::Fun(Fun { patt, body })),
};

// See https://github.com/lalrpop/lalrpop/issues/596
ExprReset = <Expr>;

pub Type: Box<Type> = {
    #[precedence(level="0")]
    Name => Box::new(Type::Base { name: <>.to_string() }),
    "(" <TypeReset> ")",
    
    #[precedence(level="1")]
    #[assoc(side="right")]
    <i:Type> "->" <o:Type> => Box::new(Type::Fun(i, o)),
}

TypeReset = <Type>;

pub Pattern: Pattern = {
    // "(" <name:Name> ":" <typ:Type> ")" => Pattern::Id { name: name.to_string(), typ: *typ }
    <name:Name> => Pattern::Id { name: name.to_string() }
}

Int: i64 = r"\-?[0-9]+" => i64::from_str(<>).unwrap();

Str: String = <s:r#""[^"]*""#> => String::from(&s[1..(s.len()-1)]);

Name: &'input str = r"[a-zA-Z]+'?";
